options {
  STATIC = false;
  LOOKAHEAD = 1;
}

PARSER_BEGIN(Parser)

import java.io.*;
import java.util.*;

public class Parser {
  private PrintWriter astWriter;
  private int indentLevel = 0;
  
  public void initASTWriter(String outputFile) {
    try {
      astWriter = new PrintWriter(new FileWriter(outputFile));
    } catch (IOException e) {
      System.err.println("Erreur lors de la cr√©ation du fichier AST: " + e.getMessage());
      astWriter = new PrintWriter(System.out);
    }
  }
  
  private void writeNode(String nodeName) {
    if (astWriter == null) {
      astWriter = new PrintWriter(System.out);
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < indentLevel; i++) {
      sb.append("  ");
    }
    sb.append(nodeName);
    astWriter.println(sb.toString());
    astWriter.flush();
  }
  
  private void writeTerminal(String tokenName) {
    if (astWriter == null) {
      astWriter = new PrintWriter(System.out);
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < indentLevel; i++) {
      sb.append("  ");
    }
    // Conversion des noms de tokens avec if-else
    String displayName = tokenName;
    if (tokenName.equals("ID")) {
      displayName = "Id";
    } else if (tokenName.equals("DOLLAR")) {
      displayName = "$";
    } else if (tokenName.equals("EQ")) {
      displayName = "=";
    } else if (tokenName.equals("AT")) {
      displayName = "@";
    } else if (tokenName.equals("AND")) {
      displayName = "&";
    } else if (tokenName.equals("HASH")) {
      displayName = "#";
    }
    sb.append(displayName);
    astWriter.println(sb.toString());
    astWriter.flush();
  }
  
  public void closeASTWriter() {
    if (astWriter != null) {
      astWriter.close();
    }
  }
}

PARSER_END(Parser)

TOKEN : { < ID : ["A"-"Z"] (["a"-"z","0"-"9","A"-"Z"])* "_" > }
TOKEN : { <DOLLAR : ["+", "*", "/"] > }
TOKEN : { <EQ : [">", "<"] > }
TOKEN : { <AT : ["(", ")"] > }
TOKEN : { <AND : ["{", "}"] > }


SKIP : { " " | "\t" | "\n" | "\r" }

void parse() : {}
{
  {
    writeNode("Programme");
    indentLevel++;
  }
  E()
  {
    indentLevel--;
  }
}

void E() : {}
{
  {
    writeNode("E");
    indentLevel++;
  }
  T() 
  {
    writeTerminal("HASH");
  }
  <EOF>
  {
    indentLevel--;
  }
}

void T() : {}
{
  {
    writeNode("T");
    indentLevel++;
  }
  (
    S() 
    | {}
  )
  {
    indentLevel--;
  }
}

void S() : {}
{
  {
    writeNode("S");
    indentLevel++;
  }
  A() 
  {
    writeTerminal("AT");
  }
  <AT> B()
  {
    indentLevel--;
  }
}

void A() : {}
{
  {
    writeNode("A");
    indentLevel++;
  }
  {
    writeTerminal("EQ");
  }
  <EQ> F()
  {
    indentLevel--;
  }
}

void G() : {}
{
  {
    writeNode("G");
    indentLevel++;
  }
  (
    {
      writeTerminal("DOLLAR");
    }
    <DOLLAR> X()
    | 
    {
      writeTerminal("AND");
    }
    <AND> A() 
    {
      writeTerminal("EQ");
    }
    <EQ> F()
  )
  {
    indentLevel--;
  }
}

void F() : {}
{
  {
    writeNode("F");
    indentLevel++;
  }
  X()
  {
    indentLevel--;
  }
}

void X() : {}
{
  {
    writeNode("X");
    indentLevel++;
  }
  {}
  {
    indentLevel--;
  }
}

void B() : {}
{
  {
    writeNode("B");
    indentLevel++;
  }
  (
    {
      writeTerminal("EQ");
    }
    <EQ> L()
    | 
    {
      writeTerminal("ID");
    }
    <ID> K()
  )
  {
    indentLevel--;
  }
}

void L() : {}
{
  {
    writeNode("L");
    indentLevel++;
  }
  S() X() 
  {
    writeTerminal("ID");
  }
  <ID> Y()
  {
    indentLevel--;
  }
}

void K() : {}
{
  {
    writeNode("K");
    indentLevel++;
  }
  Y()
  {
    indentLevel--;
  }
}

void Y() : {}
{
  {
    writeNode("Y");
    indentLevel++;
  }
  {}
  {
    indentLevel--;
  }
}