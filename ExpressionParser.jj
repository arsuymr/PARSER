options {
  STATIC = false;
  LOOKAHEAD = 1; // Utilisation d'un lookahead de 1
}

PARSER_BEGIN(Parser)

public class Parser {
  public static void main(String[] args) throws ParseException {
    Parser parser = new Parser(System.in);
    parser.Z();
    System.out.println("Parsing completed successfully.");
  }
}

PARSER_END(Parser)
TOKEN : { <ID : "[A-Z][A-Za-z0-9]*_"> }  // Identifiants : commencent par une majuscule et se terminent par "_"
TOKEN : { <DOLLAR : "[\\+\\*/]"> }        // Les opérateurs : +, *, /
TOKEN : { <EQ : "[><]"> }                  // Les opérateurs : >, <
TOKEN : { <AT : "\\(\\)"> }                // Les délimiteurs : ( )
TOKEN : { <AND : "\\{\\}"> }               // Les délimiteurs : { }
TOKEN : { <HASH : "#"> }               // Les délimiteurs : { }

SKIP : { " " | "\t" | "\n" | "\r" }  // Pour ignorer les espaces blancs, tabulations et nouvelles lignes

void Z() : {}
{
  T() <HASH>    // Z → T #
}

void T() : {}
{
  S() | {}      // T → S | ε
}

void S() : {}
{
  A() <AT> B()  // S → A @ B
| B() <AND> A() // S → B & A
}

void A() : {}
{
  B() E()      // A → B E
| <EQ> F()     // A → = F
}

void E() : {}
{
  <DOLLAR> C()  // E → $ C
| <AND> A() <EQ> F()  // E → & A = F
}

void F() : {}
{
  S() C()    // F → S C
| C()        // F → C
}

void C() : {}
{
  <AT> B() <EQ> F() // C → @ B = F
| {}                // C → ε
}

void B() : {}
{
  <EQ> G()    // B → = G
| <ID> H()    // B → id H
}

void G() : {}
{
  S() C() <ID> D() // G → S C id D
| C() <ID> D()     // G → C id D
}

void H() : {}
{
  S() D()   // H → S D
| D()       // H → D
}

void D() : {}
{
  <DOLLAR> C() <ID> D() // D → $ C id D
| <DOLLAR> A() <EQ> G() // D → $ A = G
| {}                      // D → ε
}
